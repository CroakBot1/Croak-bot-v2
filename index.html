<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Quantum Trading â€” Live Flowing Chart</title>
<style>
:root{
  --bg1:#041027; --bg2:#071021; --accent:#7afcff; --accent-2:#6de6ff; --card:#0f1b2b; --glass:rgba(255,255,255,0.03);
  --radius:18px; --ease:cubic-bezier(.2,.9,.3,1);
}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#e6f7ff}
body{background:linear-gradient(120deg,var(--bg1),var(--bg2));overflow:hidden;display:flex;align-items:center;justify-content:center}

/* --- Background blobs + animated transform for "quantum" motion --- */
.bg-blobs{position:fixed;inset:-20%;z-index:0;filter:blur(70px);opacity:.9;pointer-events:none;transform-origin:center;animation:blobMove 18s linear infinite}
@keyframes blobMove{
  0%{transform:translate3d(-3%,0,0) rotate(0deg) scale(1)}
  25%{transform:translate3d(2%,2%,0) rotate(6deg) scale(1.02)}
  50%{transform:translate3d(-2%,4%,0) rotate(-6deg) scale(1.01)}
  75%{transform:translate3d(1%,-3%,0) rotate(3deg) scale(.99)}
  100%{transform:translate3d(-3%,0,0) rotate(0deg) scale(1)}
}

/* subtle overlay grid noise for depth */
.bg-noise{
  position:fixed;inset:0;z-index:1;pointer-events:none;background-image:radial-gradient(rgba(255,255,255,0.01) 1px, transparent 1px);
  background-size: 220px 220px; mix-blend-mode:overlay; opacity:0.08; transform:translateZ(0);
}

/* canvas already exists (#particles). keep it but ensure it's behind overlay */
#particles{position:fixed;inset:0;z-index:0;pointer-events:none}

/* overlay + card unchanged (z-index kept) */
.overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:10}
.card{position:relative;z-index:20;width:min(460px,96%);max-width:480px;padding:26px;border-radius:20px;
  background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  box-shadow:0 30px 80px rgba(2,8,23,0.7);backdrop-filter:blur(8px);
  display:flex;flex-direction:column;gap:20px;align-items:center;overflow:visible}

.logo-wrap{display:flex;flex-direction:column;align-items:center;gap:12px}
.logo{width:140px;height:140px;border-radius:16px;background:linear-gradient(135deg,#072033,#0d2c40);
  display:flex;align-items:center;justify-content:center;font-weight:800;font-size:34px;color:var(--accent);
  box-shadow:inset 0 -12px 30px rgba(0,0,0,0.5);transform-style:preserve-3d;animation:logoFloat 4s ease-in-out infinite}
@keyframes logoFloat{0%{transform:translateY(0) rotateX(0) rotateY(0)}50%{transform:translateY(-8px) rotateX(6deg) rotateY(6deg)}100%{transform:translateY(0) rotateX(0) rotateY(0)}}
.orb{position:absolute;width:18px;height:18px;border-radius:50%;background:var(--accent);box-shadow:0 8px 24px rgba(122,252,255,0.15);animation:orbOrbit 3.8s linear infinite}
@keyframes orbOrbit{0%{transform:translate(-120px,-40px)}50%{transform:translate(120px,40px)}100%{transform:translate(-120px,-40px)}}

.content{text-align:center}
.content h1{margin:0;font-size:26px;line-height:1.05}
.muted{color:rgba(230,247,255,0.75);margin-top:6px}
.typing{font-weight:700;color:var(--accent);display:inline-block;white-space:nowrap;overflow:hidden;border-right:2px solid rgba(122,252,255,0.5);animation:blinkCaret 1s step-end infinite}
@keyframes blinkCaret{50%{border-color:transparent}}

.ticker{margin-top:12px;background:linear-gradient(90deg, rgba(122,252,255,0.03), rgba(122,252,255,0.01));
  padding:8px;border-radius:10px;overflow:hidden;border:1px solid rgba(255,255,255,0.03)}
.ticker .marquee{display:inline-block;white-space:nowrap;animation:marquee 16s linear infinite}
@keyframes marquee{0%{transform:translateX(0)}100%{transform:translateX(-50%)}}
.tick-item{display:inline-flex;gap:10px;align-items:center;padding:0 18px}
.tick-symbol{font-weight:700;color:var(--accent);min-width:60px}

.chart{width:100%;height:60px;margin-top:14px;overflow:hidden;position:relative}
.chart svg{width:100%;height:100%;position:absolute;top:0;left:0}
.spark path{fill:none;stroke-width:2.5;stroke-linecap:round;stroke-linejoin:round;opacity:0.95;transition:d 0.1s linear}

.actions{display:flex;gap:12px;margin-top:16px;align-items:center;flex-wrap:wrap;justify-content:center}
.btn{padding:10px 16px;border-radius:12px;border:0;cursor:pointer;font-weight:700;
  background:linear-gradient(90deg,var(--accent),#5ee7ff);color:#041822;
  box-shadow:0 12px 40px rgba(122,252,255,0.12);transform-origin:center;transition:transform .18s ease}
.btn:hover{transform:translateY(-4px) scale(1.03)}
.ghost{background:transparent;color:#dff7ff;border:1px solid rgba(255,255,255,0.06)}

.select-bot{padding:10px 14px;border-radius:12px;border:1px solid rgba(255,255,255,0.1);
  background:rgba(0,0,0,0.3);color:#e6f7ff;font-weight:700;cursor:pointer;transition:0.2s}
.select-bot:hover{background:rgba(0,0,0,0.5)}

.bot{display:flex;align-items:center;gap:12px;margin-top:16px;justify-content:center}
.avatar{width:72px;height:72px;border-radius:14px;background:linear-gradient(135deg,#072033,#0b2b3e);
  display:flex;align-items:center;justify-content:center;font-size:28px;color:var(--accent);
  box-shadow:0 10px 30px rgba(0,0,0,0.45);animation:avatarBounce 3.2s ease-in-out infinite}
@keyframes avatarBounce{0%{transform:translateY(0)}50%{transform:translateY(-8px)}100%{transform:translateY(0)}}
.wave{width:120px;height:28px;display:block}
.wave svg{width:100%;height:100%}
.wave path{fill:none;stroke:var(--accent);stroke-width:2;stroke-linecap:round;animation:wave 1.6s linear infinite}
@keyframes wave{0%{stroke-dashoffset:0}50%{stroke-dashoffset:18}100%{stroke-dashoffset:36}}

/* small responsive tuning */
@media (min-width:1100px){
  .card{width:520px;max-width:680px;padding:32px}
  .logo{width:160px;height:160px;font-size:38px}
}

/* keep canvas crisp on high-dpi */
canvas {image-rendering: -webkit-optimize-contrast;}
</style>
</head>
<body>
<svg class="bg-blobs" viewBox="0 0 800 600" preserveAspectRatio="xMidYMid slice">
  <defs>
    <linearGradient id="g1" x1="0" x2="1"><stop offset="0" stop-color="#05263a"/><stop offset="1" stop-color="#071b2b"/></linearGradient>
    <filter id="softGlow" x="-50%" y="-50%" width="200%" height="200%">
      <feGaussianBlur stdDeviation="30" result="blur"/>
      <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
    </filter>
  </defs>
  <g filter="url(#softGlow)">
    <ellipse cx="120" cy="80" rx="260" ry="140" fill="#07304a" opacity="0.6"></ellipse>
    <ellipse cx="700" cy="520" rx="300" ry="200" fill="#03405a" opacity="0.5"></ellipse>
    <!-- extra subtle orb for depth -->
    <ellipse cx="420" cy="280" rx="180" ry="120" fill="#062a3a" opacity="0.28"></ellipse>
  </g>
</svg>
<div class="bg-noise" aria-hidden="true"></div>
<canvas id="particles"></canvas>

<div class="overlay">
  <div class="card">
    <div class="logo-wrap">
      <div class="logo">QT</div>
      <div style="font-size:13px;color:rgba(230,247,255,0.7)">Quantum Trading Bot</div>
      <div class="orb" style="left:42px;top:26px"></div>
    </div>
    <div class="content">
      <h1><span class="typing" id="typing">Adaptive market signals</span></h1>
      <div class="muted">Prepare strategies backed by AI-driven insights â€” live flowing preview</div>

      <div class="ticker" aria-hidden="true"><div class="marquee" id="marquee"></div></div>

      <div class="chart" aria-hidden="true">
        <svg viewBox="0 0 400 60" preserveAspectRatio="none" class="spark">
          <path id="btc" stroke="#f7931a"/>
          <path id="eth" stroke="#627eea"/>
          <path id="sol" stroke="#00ffa3"/>
          <path id="doge" stroke="#c2a633"/>
          <path id="ada" stroke="#3cc8c8"/>
        </svg>
      </div>

      <div class="bot">
        <div class="avatar">ðŸ¤–</div>
        <div>
          <div style="font-weight:700">Croakus AI</div>
          <div style="font-size:13px;color:rgba(230,247,255,0.7)">Realtime market signals</div>
          <div class="wave" aria-hidden="true">
            <svg viewBox="0 0 120 28" preserveAspectRatio="none">
              <path d="M0 18 Q20 6 40 14 T120 12" stroke="rgba(122,252,255,0.9)" stroke-width="2" stroke-linecap="round" fill="none" stroke-dasharray="6 6"></path>
            </svg>
          </div>
        </div>
      </div>

      <div class="actions">
        <select id="botSelect" class="select-bot">
          <option value="https://croak-bot-proxy-three.vercel.app/">Bot 1</option>
          <option value="https://croak-express-gateway-henna.vercel.app/">Bot 2</option>
          <option value="https://croak-pwa.vercel.app/">Bot 3</option>
        </select>
        <button class="btn" id="goBtn">Go</button>
        <button class="btn ghost" id="demoBtn">View Demo</button>
        <a href="https://t.me/QuantumTradingBot1" target="_blank" class="btn">Join Telegram</a>
        <!-- NEW Guidelines button -->
        <a href="https://croakbotpage.vercel.app/" target="_blank" class="btn">Guidelines</a>
      </div>
    </div>
  </div>
</div>

<script>
// --- particles (enhanced to create quantum-style connected nodes + orbiting electrons) ---
const canvas=document.getElementById('particles'), ctx=canvas.getContext('2d');
let w,h,particles=[];
function resize(){const dpr = Math.max(1, window.devicePixelRatio || 1); w=canvas.width=innerWidth * dpr; h=canvas.height=innerHeight * dpr; canvas.style.width=innerWidth+'px'; canvas.style.height=innerHeight+'px'; ctx.setTransform(dpr,0,0,dpr,0,0);}
window.addEventListener('resize',resize); resize();

function rnd(min,max){return Math.random()*(max-min)+min}
function initParticles(){
  particles=[];
  const count = Math.max(60, Math.floor((innerWidth+innerHeight)/60)); // adaptive count but won't be huge
  for(let i=0;i<count;i++){
    particles.push({
      x:rnd(0,innerWidth),
      y:rnd(0,innerHeight),
      r:rnd(0.6,2.4),
      vx:rnd(-0.25,0.25),
      vy:rnd(-0.12,0.12),
      alpha:rnd(0.04,0.2),
      orbitR: rnd(6,22),
      orbitSpeed: rnd(0.01,0.045),
      orbitAngle: rnd(0,Math.PI*2),
      charge: rnd(-1,1)
    });
  }
}
initParticles();

let lastTime = performance.now();
function draw(now){
  const dt = Math.min(40, now - lastTime);
  lastTime = now;
  ctx.clearRect(0,0,innerWidth,innerHeight);

  const grd = ctx.createRadialGradient(innerWidth*0.3, innerHeight*0.2, innerWidth*0.05, innerWidth*0.5, innerHeight*0.5, Math.max(innerWidth,innerHeight));
  grd.addColorStop(0, 'rgba(10,20,30,0.05)');
  grd.addColorStop(1, 'rgba(2,6,12,0.2)');
  ctx.fillStyle = grd;
  ctx.fillRect(0,0,innerWidth,innerHeight);

  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  for(let i=0;i<particles.length;i++){
    const p = particles[i];
    for(let j=i+1;j<particles.length;j++){
      const q = particles[j];
      const dx = p.x - q.x, dy = p.y - q.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      const thresh = 140;
      if(dist < thresh){
        const alpha = (1 - (dist / thresh)) * 0.08 + (p.alpha+q.alpha)/50;
        const mix = (p.charge + q.charge) * 0.5;
        const r = Math.floor(122 + mix*60);
        const g = Math.floor(252 - Math.abs(mix)*120);
        const b = Math.floor(255 - mix*40);
        ctx.strokeStyle = `rgba(${r},${g},${b},${alpha})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(q.x, q.y);
        ctx.stroke();
      }
    }
  }
  ctx.restore();

  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  for(let p of particles){
    p.x += p.vx * (dt/16);
    p.y += p.vy * (dt/16);
    if(p.x < -60) p.x = innerWidth + 60;
    if(p.x > innerWidth + 60) p.x = -60;
    if(p.y < -60) p.y = innerHeight + 60;
    if(p.y > innerHeight + 60) p.y = -60;

    p.vx += (Math.sin((now/4000)+p.x*0.0007) * 0.01);
    p.vy += (Math.cos((now/5000)+p.y*0.0005) * 0.006);

    const coreR = Math.max(0.6, p.r);
    ctx.beginPath();
    ctx.fillStyle = `rgba(122,252,255,${p.alpha*0.9})`;
    ctx.arc(p.x, p.y, coreR*1.6, 0, Math.PI*2);
    ctx.fill();

    const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, coreR*8);
    g.addColorStop(0, `rgba(122,252,255,${p.alpha*0.6})`);
    g.addColorStop(1, 'rgba(122,252,255,0)');
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(p.x, p.y, coreR*8, 0, Math.PI*2);
    ctx.fill();

    p.orbitAngle += p.orbitSpeed * (dt/16);
    const ex = p.x + Math.cos(p.orbitAngle) * p.orbitR;
    const ey = p.y + Math.sin(p.orbitAngle) * p.orbitR;
    ctx.beginPath();
    ctx.fillStyle = `rgba(110,230,255,${Math.min(0.9, p.alpha*6)})`;
    ctx.arc(ex, ey, Math.max(0.9, coreR*0.6), 0, Math.PI*2);
    ctx.fill();

    ctx.beginPath();
    ctx.strokeStyle = `rgba(110,230,255,${Math.min(0.08, p.alpha*0.2)})`;
    ctx.lineWidth = 1;
    ctx.moveTo(ex, ey);
    ctx.lineTo(p.x + Math.cos(p.orbitAngle-0.5) * (p.orbitR*0.6), p.y + Math.sin(p.orbitAngle-0.5) * (p.orbitR*0.6));
    ctx.stroke();
  }
  ctx.restore();

  requestAnimationFrame(draw);
}
requestAnimationFrame(draw);

let resizeTimer;
window.addEventListener('resize', ()=>{
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(()=>{ initParticles(); }, 180);
});

// --- typing ---
const typingEl=document.getElementById('typing');const phrases=['Adaptive market signals','Autonomous scalping engine','Risk-managed entries','Quantum-aware strategies'];let i=0,j=0,forward=true;
function typeStep(){const cur=phrases[i];if(forward){j++;typingEl.textContent=cur.slice(0,j);if(j===cur.length){forward=false;setTimeout(typeStep,900);return}}else{j--;typingEl.textContent=cur.slice(0,j);if(j===0){forward=true;i=(i+1)%phrases.length}}setTimeout(typeStep,forward?90:40)}
typeStep();

// --- bubble dismiss + buttons ---
const overlay=document.querySelector('.overlay');const bubble=document.createElement('div');bubble.style.position='fixed';bubble.style.width='220px';bubble.style.height='220px';bubble.style.borderRadius='50%';bubble.style.pointerEvents='none';bubble.style.zIndex='18';bubble.style.background='radial-gradient(circle at 35% 30%, rgba(122,252,255,0.95), rgba(122,252,255,0.18) 40%, transparent 70%)';bubble.style.filter='blur(6px)';document.body.appendChild(bubble);
function dismiss(x=null,y=null){if(x&&y){bubble.style.left=(x-110)+'px';bubble.style.top=(y-110)+'px'}else{bubble.style.left='50%';bubble.style.top='50%';}bubble.animate([{transform:'scale(.12)',opacity:1},{transform:'scale(.9)',offset:.35},{transform:'translateY(-200px) scale(2.8)',opacity:0}],{duration:800,easing:'cubic-bezier(.2,.9,.3,1)'});overlay.style.transition='opacity .6s ease';overlay.style.opacity='0';setTimeout(()=>overlay.remove(),750);}
document.getElementById('goBtn').addEventListener('click',(e)=>{const sel=document.getElementById('botSelect');const url=sel.value;const r=e.target.getBoundingClientRect();dismiss(r.left+r.width/2,r.top+r.height/2);setTimeout(()=>window.location.href=url,500);});
document.getElementById('demoBtn').addEventListener('click',()=>{alert('Demo opened â€” replace with your demo handler')});
window.addEventListener('keydown',(e)=>{if(e.key==='Escape'&&document.querySelector('.overlay')){dismiss()}});

// --- live flowing chart ---
const coins=['bitcoin','ethereum','solana','dogecoin','cardano'],maxPoints=60;
const marquee=document.getElementById('marquee');
const pathEls={btc:document.getElementById('btc'),eth:document.getElementById('eth'),sol:document.getElementById('sol'),doge:document.getElementById('doge'),ada:document.getElementById('ada')};
const priceHistory={bitcoin:Array(maxPoints).fill(0),ethereum:Array(maxPoints).fill(0),solana:Array(maxPoints).fill(0),dogecoin:Array(maxPoints).fill(0),cardano:Array(maxPoints).fill(0)};

async function fetchPrices(){
  try{
    const res=await fetch('https://api.coingecko.com/api/v3/simple/price?ids='+coins.join(',')+'&vs_currencies=usd&include_24hr_change=true');
    const data=await res.json();
    marquee.innerHTML = coins.map(c=>{
      const symbol=c==='bitcoin'?'BTC':c==='ethereum'?'ETH':c==='solana'?'SOL':c==='dogecoin'?'DOGE':'ADA';
      const price=data[c].usd.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});
      const change=(data[c].usd_24h_change||0).toFixed(2);
      const arrow=change>=0?'â–²':'â–¼';
      return `<span class="tick-item"><span class="tick-symbol">${symbol}</span> ${price} ${arrow} ${Math.abs(change)}%</span>`;
    }).join(' ')+' '+coins.map(c=>{
      const symbol=c==='bitcoin'?'BTC':c==='ethereum'?'ETH':c==='solana'?'SOL':c==='dogecoin'?'DOGE':'ADA';
      const price=data[c].usd.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});
      const change=(data[c].usd_24h_change||0).toFixed(2);
      const arrow=change>=0?'â–²':'â–¼';
      return `<span class="tick-item"><span class="tick-symbol">${symbol}</span> ${price} ${arrow} ${Math.abs(change)}%</span>`;
    }).join(' ');
    coins.forEach(c=>{
      const arr=priceHistory[c];
      arr.push(data[c].usd);
      if(arr.length>maxPoints) arr.shift();
      const min=Math.min(...arr),max=Math.max(...arr);
      const svgW=400,svgH=60;
      let d='';
      arr.forEach((p,i)=>{const x=(i/(maxPoints-1))*svgW;const y=svgH - ((p-min)/(max-min||1))*svgH;d += (i===0?'M':'L')+x+' '+y+' ';});
      pathEls[c].setAttribute('d',d);
    });
  }catch(e){console.error(e)}
}
fetchPrices(); setInterval(fetchPrices,3000);
</script>
</body>
</html>
<!-- Add-on Script: Floating About Us Button (Always on Top Header) -->
<script>
  (function(){
    const aboutBtn = document.createElement('button');
    aboutBtn.textContent = 'About Us';
    aboutBtn.style.cssText = `
      position: fixed;
      top: 20px; /* ibutang sa taas */
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 22px;
      background: linear-gradient(90deg, #7afcff, #6de6ff);
      border: none;
      border-radius: 12px;
      color: #041027;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 6px 14px rgba(0,0,0,0.25);
      transition: all 0.25s ease;
      z-index: 99999; /* pinakataas gyud */
    `;

    // Hover animation
    aboutBtn.addEventListener('mouseover', () => {
      aboutBtn.style.transform = 'translateX(-50%) scale(1.08)';
      aboutBtn.style.boxShadow = '0 10px 20px rgba(0,0,0,0.35)';
    });
    aboutBtn.addEventListener('mouseout', () => {
      aboutBtn.style.transform = 'translateX(-50%) scale(1)';
      aboutBtn.style.boxShadow = '0 6px 14px rgba(0,0,0,0.25)';
    });

    // Click event â†’ open About Us page
    aboutBtn.addEventListener('click', () => {
      window.open('https://about-us-green.vercel.app/', '_blank');
    });

    // Append to body
    document.body.appendChild(aboutBtn);
  })();
</script>

<!-- Add-on Script: Ultra-Realistic Alien Fleet with Dynamic Lighting -->
<script>
const shipCanvas = document.createElement('canvas');
shipCanvas.style.position = 'fixed';
shipCanvas.style.inset = '0';
shipCanvas.style.zIndex = '0';
shipCanvas.style.pointerEvents = 'none';
document.body.appendChild(shipCanvas);
const sctx = shipCanvas.getContext('2d');

let sw, sh;
function resizeShips() {
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  sw = shipCanvas.width = window.innerWidth * dpr;
  sh = shipCanvas.height = window.innerHeight * dpr;
  shipCanvas.style.width = window.innerWidth + 'px';
  shipCanvas.style.height = window.innerHeight + 'px';
  sctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener('resize', resizeShips);
resizeShips();

class AlienShip {
  constructor(type) {
    this.type = type;
    this.reset();
  }

  reset() {
    this.z = Math.random() * 0.9 + 0.1; // depth
    this.x = (Math.random() - 0.5) * sw;
    this.y = (Math.random() - 0.5) * sh * 0.3;
    this.size = Math.random() * 22 + 18;
    this.speed = Math.random() * 0.025 + 0.01;
    this.rotation = Math.random() * Math.PI * 2;
    this.bank = (Math.random() - 0.5) * 0.5;
    this.trail = [];
    this.thrusterColor = `rgba(${50+Math.random()*205},${50+Math.random()*205},255,0.8)`;
    this.bodyGlow = `rgba(50,255,255,${Math.random()*0.2 + 0.1})`;
  }

  draw() {
    const scale = 1 / this.z;
    const x = sw / 2 + this.x * scale;
    const y = sh / 2 + this.y * scale;
    const s = this.size * scale;
    const alpha = Math.min(1, 1 - this.z);

    // Trail
    this.trail.push({x,y,s});
    if(this.trail.length>35) this.trail.shift();
    sctx.save();
    sctx.lineWidth = 2*scale;
    sctx.strokeStyle = `rgba(0,255,255,${alpha*0.15})`;
    sctx.beginPath();
    this.trail.forEach((t,i)=> i===0 ? sctx.moveTo(t.x,t.y) : sctx.lineTo(t.x,t.y));
    sctx.stroke();
    sctx.restore();

    // Thruster glow with dynamic blur based on speed
    sctx.save();
    const blurAmt = 20*scale*(0.5+this.speed*10);
    sctx.shadowColor = this.thrusterColor;
    sctx.shadowBlur = blurAmt;
    sctx.fillStyle = this.thrusterColor;
    sctx.beginPath();
    sctx.ellipse(x, y + s*0.25, s*0.22, s*0.1, this.rotation, 0, Math.PI*2);
    sctx.fill();
    sctx.restore();

    // Body with dynamic lighting
    sctx.save();
    sctx.globalAlpha = alpha;
    sctx.shadowColor = this.bodyGlow;
    sctx.shadowBlur = 8*scale;
    sctx.strokeStyle = `rgba(0,255,255,${alpha*0.25})`;
    sctx.lineWidth = 1.5;
    sctx.fillStyle = 'black';

    if(this.type===0){ // saucer
      sctx.beginPath();
      sctx.ellipse(x, y, s*0.7, s*0.25, this.rotation+this.bank,0,Math.PI*2);
      sctx.fill();
      sctx.stroke();
    } else if(this.type===1){ // triangular
      sctx.beginPath();
      sctx.moveTo(x, y - s*0.25);
      sctx.lineTo(x - s*0.35, y + s*0.25);
      sctx.lineTo(x + s*0.35, y + s*0.25);
      sctx.closePath();
      sctx.fill();
      sctx.stroke();
    } else if(this.type===2){ // double wing
      sctx.beginPath();
      sctx.ellipse(x, y, s*0.55, s*0.2, this.rotation+this.bank,0,Math.PI*2);
      sctx.fill();
      sctx.stroke();
      sctx.beginPath();
      sctx.moveTo(x - s*0.5, y);
      sctx.lineTo(x, y - s*0.15);
      sctx.lineTo(x, y + s*0.15);
      sctx.closePath();
      sctx.fill();
      sctx.stroke();
      sctx.beginPath();
      sctx.moveTo(x + s*0.5, y);
      sctx.lineTo(x, y - s*0.15);
      sctx.lineTo(x, y + s*0.15);
      sctx.closePath();
      sctx.fill();
      sctx.stroke();
    }
    sctx.restore();
  }

  update() {
    this.z -= this.speed;
    if(this.z <=0.02) this.reset();
    this.draw();
  }
}

// fleet
const ships = [];
for(let i=0;i<10;i++){
  ships.push(new AlienShip(Math.floor(Math.random()*3)));
}

function animateFleet(){
  sctx.clearRect(0,0,sw,sh);

  // subtle light reflection from background blobs
  const grd = sctx.createRadialGradient(sw/2, sh/2, 0, sw/2, sh/2, Math.max(sw,sh));
  grd.addColorStop(0, 'rgba(5,20,35,0.03)');
  grd.addColorStop(1, 'rgba(2,6,12,0.1)');
  sctx.fillStyle = grd;
  sctx.fillRect(0,0,sw,sh);

  ships.forEach(ship => ship.update());
  requestAnimationFrame(animateFleet);
}
animateFleet();
</script>
<script>
// --- Quantum Trading Logo SVG Injection ---
(function(){
  const wrap = document.querySelector('.logo-wrap');
  if(!wrap) return;

  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("viewBox", "0 0 750 200");
  svg.setAttribute("width", "240");
  svg.setAttribute("height", "64");
  svg.style.display = "block";

  svg.innerHTML = `
    <defs>
      <mask id="ring-hole">
        <rect width="100%" height="100%" fill="black"/>
        <circle cx="120" cy="100" r="70" fill="white"/>
        <circle cx="120" cy="100" r="48" fill="black"/>
      </mask>
      <linearGradient id="ringGradient" x1="0%" y1="0%" x2="100%" y2="100%">
        <stop offset="0%" stop-color="#5affd6"/>
        <stop offset="100%" stop-color="#0ea68f"/>
      </linearGradient>
      <radialGradient id="circleGradient" cx="50%" cy="40%" r="70%">
        <stop offset="0%" stop-color="#5affd6" />
        <stop offset="100%" stop-color="#0ea68f" />
      </radialGradient>
      <linearGradient id="textGradient" x1="0%" y1="0%" x2="0%" y2="100%">
        <stop offset="0%" stop-color="#ffffff"/>
        <stop offset="100%" stop-color="#cccccc"/>
      </linearGradient>
      <filter id="softShadow" x="-50%" y="-50%" width="200%" height="200%">
        <feGaussianBlur in="SourceAlpha" stdDeviation="6" result="blur"/>
        <feOffset dx="4" dy="4" result="offsetBlur"/>
        <feMerge>
          <feMergeNode in="offsetBlur"/>
          <feMergeNode in="SourceGraphic"/>
        </feMerge>
      </filter>
      <style type="text/css">
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@700&display=swap');
        .brand-text {
          font-family: 'Poppins', sans-serif;
          font-weight: 700;
        }
      </style>
    </defs>

    <rect width="100%" height="100%" fill="#071826" />
    <g mask="url(#ring-hole)" filter="url(#softShadow)">
      <circle cx="120" cy="100" r="70" fill="url(#ringGradient)" />
    </g>
    <circle cx="170" cy="128" r="30" fill="url(#circleGradient)" filter="url(#softShadow)" />
    <circle cx="160" cy="118" r="28" fill="#05353c" opacity="0.7" />
    <ellipse cx="170" cy="115" rx="14" ry="8" fill="white" opacity="0.25"/>
    <circle cx="120" cy="100" r="70" fill="none" stroke="#5affd6" stroke-width="2" opacity="0.9"/>
    <text x="240" y="125" font-size="72" fill="url(#textGradient)" class="brand-text" letter-spacing="2" filter="url(#softShadow)">
      Quantum
    </text>
  `;

  // replace QT div with SVG logo
  wrap.querySelector('.logo').remove();
  wrap.insertBefore(svg, wrap.firstChild);
})();
</script>
<!-- Add-on Script: Auto Zoom on PC -->
<script>
(function() {
  function applyZoom() {
    if (window.innerWidth > 1024) { 
      // kung PC or large screen
      document.body.style.zoom = "1.2";   // 120% zoom
      document.body.style.transform = "scale(1.2)";
      document.body.style.transformOrigin = "top center";
    } else {
      // kung mobile/tablet, normal lang
      document.body.style.zoom = "1";
      document.body.style.transform = "none";
    }
  }

  // initial load
  applyZoom();

  // listen if resized
  window.addEventListener("resize", applyZoom);
})();
</script>
<!-- Add-on Script: Realistic Atomic Bomb Explosion Background (Random Areas) -->
<script>
(function(){
  const expCanvas = document.createElement("canvas");
  expCanvas.style.position = "fixed";
  expCanvas.style.inset = "0";
  expCanvas.style.zIndex = "-1";
  expCanvas.style.background = "radial-gradient(ellipse at center, #111 0%, #000 100%)"; 
  document.body.appendChild(expCanvas);

  const ctx = expCanvas.getContext("2d");
  let w = window.innerWidth, h = window.innerHeight;
  expCanvas.width = w; expCanvas.height = h;

  window.addEventListener("resize", ()=>{
    w = window.innerWidth; h = window.innerHeight;
    expCanvas.width = w; expCanvas.height = h;
  });

  // Particle system for mushroom cloud
  class Particle {
    constructor(x,y,r,clr,vx,vy,life){
      this.x=x; this.y=y;
      this.r=r;
      this.clr=clr;
      this.vx=vx; this.vy=vy;
      this.life=life;
      this.opacity=1;
    }
    update(){
      this.x+=this.vx;
      this.y+=this.vy;
      this.vx*=0.98;
      this.vy*=0.98;
      this.r*=0.99;
      this.life--;
      this.opacity=this.life/200;
    }
    draw(){
      const g=ctx.createRadialGradient(this.x,this.y,0,this.x,this.y,this.r);
      g.addColorStop(0,`rgba(${this.clr},${this.opacity})`);
      g.addColorStop(1,"rgba(0,0,0,0)");
      ctx.fillStyle=g;
      ctx.beginPath();
      ctx.arc(this.x,this.y,this.r,0,Math.PI*2);
      ctx.fill();
    }
  }

  let particles=[];
  function createExplosion(){
    // RANDOM location on screen
    const baseX = Math.random()*w*0.8 + w*0.1; 
    const baseY = Math.random()*h*0.5 + h*0.4; 

    // fireball core
    for(let i=0;i<100;i++){
      particles.push(new Particle(
        baseX+(Math.random()-0.5)*30,
        baseY+(Math.random()-0.5)*30,
        80+Math.random()*80,
        "255,140,60",
        (Math.random()-0.5)*4,
        (Math.random()-0.5)*2,
        250+Math.random()*50
      ));
    }
    // mushroom stem & smoke cloud
    for(let i=0;i<350;i++){
      const angle=Math.random()*Math.PI*2;
      const speed=Math.random()*2;
      particles.push(new Particle(
        baseX+Math.cos(angle)*15,
        baseY-60-Math.random()*70,
        25+Math.random()*50,
        "220,220,220",
        Math.cos(angle)*speed,
        -Math.random()*2-1,
        400+Math.random()*200
      ));
    }
  }

  // first explosion
  createExplosion();

  function animate(){
    // dark sky background fade
    ctx.fillStyle="rgba(10,10,20,0.4)";
    ctx.fillRect(0,0,w,h);

    particles.forEach((p,i)=>{
      p.update(); 
      p.draw();
      if(p.life<=0) particles.splice(i,1);
    });

    // random new explosion when particles < threshold
    if(particles.length < 150) createExplosion(); 
    requestAnimationFrame(animate);
  }
  animate();
})();
</script>
<!-- Random Laser Attack Background (drop before </body>) -->
<style>
  /* Canvas sits behind content */
  #laser-bg-canvas {
    position: fixed;
    inset: 0;
    width: 100vw;
    height: 100vh;
    pointer-events: none;
    z-index: -1; /* behind page content */
    opacity: 1;
    mix-blend-mode: screen; /* bright additive look */
    will-change: transform; /* performance hint */
  }
</style>

<canvas id="laser-bg-canvas" aria-hidden="true"></canvas>

<script>
/*
  Random Laser Attack Background
  - Drop into any page.
  - call LaserBG.init(options) to init (auto-init at bottom).
  - call LaserBG.start() / LaserBG.stop() to control.
*/

const LaserBG = (function () {
  // Config defaults
  const cfg = {
    laserFrequency: 0.8,    // avg lasers per second
    maxConcurrentLasers: 3, // concurrent beams at once
    laserLife: 700,         // ms lifetime of a beam (fade out)
    laserThickness: 2.5,    // base thickness (px)
    glowRadius: 22,         // shadow blur for glow
    sparkCount: 28,         // sparks on impact
    sparkLife: 600,         // ms
    impactFlash: true,      // small bloom on impact
    randomSourceEdges: true,// lasers originate from edges (true) or anywhere (false)
    mobileScale: 0.6,       // scale down effect on small screens
    maxFPS: 60,             // cap framerate
    seed: Math.random() * 1e6
  };

  let canvas, ctx, width, height, devicePixelRatio;
  let running = false;
  let lastFrame = 0;
  let lasers = [];   // active laser beams
  let sparks = [];   // impact particles
  let rafId = null;
  let rng = mulberry32(cfg.seed);

  // Simple deterministic RNG for consistent randomness if needed
  function mulberry32(a) {
    return function () {
      a |= 0;
      a = a + 0x6D2B79F5 | 0;
      let t = Math.imul(a ^ a >>> 15, 1 | a);
      t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  function initCanvas() {
    canvas = document.getElementById('laser-bg-canvas');
    if (!canvas) {
      canvas = document.createElement('canvas');
      canvas.id = 'laser-bg-canvas';
      document.body.appendChild(canvas);
    }
    ctx = canvas.getContext('2d', { alpha: true });
    resize();
    window.addEventListener('resize', resize);
    // Pause on tab hidden to save CPU
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) stop();
      else if (running) start();
    });
  }

  function resize() {
    devicePixelRatio = Math.max(1, window.devicePixelRatio || 1);
    width = Math.max(1, innerWidth);
    height = Math.max(1, innerHeight);
    // reduce intensity on small screens
    const scale = (Math.min(width, height) < 600) ? cfg.mobileScale : 1;
    const dpr = devicePixelRatio * scale;
    canvas.width = Math.round(width * dpr);
    canvas.height = Math.round(height * dpr);
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  // Beam factory
  function spawnLaser() {
    if (lasers.length >= cfg.maxConcurrentLasers) return;
    // choose origin point (edges or anywhere)
    let ox, oy, tx, ty;
    if (cfg.randomSourceEdges) {
      const edge = Math.floor(rng() * 4);
      // edges: top(0), right(1), bottom(2), left(3)
      if (edge === 0) { ox = rng() * width; oy = -20; }
      if (edge === 1) { ox = width + 20; oy = rng() * height; }
      if (edge === 2) { ox = rng() * width; oy = height + 20; }
      if (edge === 3) { ox = -20; oy = rng() * height; }
    } else {
      ox = rng() * width; oy = rng() * height;
    }

    // target is random point within screen, biased toward center
    const cx = width / 2, cy = height / 2;
    const bias = 0.8;
    tx = cx + (rng() - 0.5) * width * (1 - bias);
    ty = cy + (rng() - 0.5) * height * (1 - bias);
    // or fully random sometimes
    if (rng() > 0.65) { tx = rng() * width; ty = rng() * height; }

    const angleJitter = (rng() - 0.5) * 0.12;
    const speed = 1 + rng() * 2.2;
    const thickness = cfg.laserThickness * (0.6 + rng() * 1.4);
    const hue = Math.floor(180 + rng() * 140); // teal -> magenta range

    lasers.push({
      ox, oy, tx, ty,
      start: performance.now(),
      life: cfg.laserLife * (0.7 + rng() * 0.7),
      speed,
      thickness,
      hue,
      jitter: angleJitter,
      id: Math.random()
    });
  }

  // Spawn sparks for impacts
  function spawnSparks(x, y, hue) {
    const count = Math.floor(cfg.sparkCount * (0.6 + rng() * 0.8));
    for (let i = 0; i < count; i++) {
      const ang = rng() * Math.PI * 2;
      const speed = 0.6 + rng() * 5;
      sparks.push({
        x, y,
        vx: Math.cos(ang) * speed,
        vy: Math.sin(ang) * speed,
        life: cfg.sparkLife * (0.6 + rng() * 0.8),
        born: performance.now(),
        size: 0.8 + rng() * 2.6,
        hue,
        id: Math.random()
      });
    }
  }

  // draw single laser beam with inner core + glow + faded tail
  function drawLaser(l, tnow) {
    const elapsed = tnow - l.start;
    const p = Math.min(1, elapsed / l.life);
    // ease out for fade
    const alpha = Math.max(0, 1 - p);
    // beam current endpoint interpolated
    const ex = l.ox + (l.tx - l.ox) * Math.min(1, p * l.speed);
    const ey = l.oy + (l.ty - l.oy) * Math.min(1, p * l.speed);

    // light beam core
    ctx.save();
    ctx.globalCompositeOperation = 'screen';

    // outer glow
    ctx.lineWidth = l.thickness * 6;
    ctx.strokeStyle = `hsla(${l.hue},100%,60%,${0.08 * alpha})`;
    ctx.shadowBlur = cfg.glowRadius * (1 + (1 - p) * 0.8);
    ctx.shadowColor = `hsla(${l.hue},100%,60%,0.9)`;
    ctx.beginPath();
    ctx.moveTo(l.ox, l.oy);
    // subtle curve by using a control point
    const cx = (l.ox + ex) / 2 + Math.sin(elapsed * 0.01 + l.jitter) * 40 * (1 - p);
    const cy = (l.oy + ey) / 2 + Math.cos(elapsed * 0.01 + l.jitter) * 30 * (1 - p);
    ctx.quadraticCurveTo(cx, cy, ex, ey);
    ctx.stroke();

    // bright thin core
    ctx.lineWidth = l.thickness;
    ctx.shadowBlur = 0;
    // core is bright white with color tint
    ctx.strokeStyle = `hsla(${l.hue},100%,95%,${0.95 * alpha})`;
    ctx.beginPath();
    ctx.moveTo(l.ox, l.oy);
    ctx.quadraticCurveTo(cx, cy, ex, ey);
    ctx.stroke();

    // inner very thin neon line
    ctx.lineWidth = Math.max(1, l.thickness * 0.5);
    ctx.strokeStyle = `hsla(${l.hue},100%,70%,${0.5 * alpha})`;
    ctx.beginPath();
    ctx.moveTo(l.ox, l.oy);
    ctx.quadraticCurveTo(cx, cy, ex, ey);
    ctx.stroke();

    ctx.restore();

    // if beam nearly reached target, spawn impact effects
    if (p >= 1 || Math.hypot(ex - l.tx, ey - l.ty) < 12) {
      spawnSparks(l.tx, l.ty, l.hue);
      // optional flash: draw a short-lived circular bloom
      if (cfg.impactFlash) {
        const flashAlpha = Math.min(0.9, 1 - p);
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.beginPath();
        const r = 14 + (1 - p) * 60;
        const gradient = ctx.createRadialGradient(l.tx, l.ty, 0, l.tx, l.ty, r);
        gradient.addColorStop(0, `hsla(${l.hue},100%,85%,${flashAlpha * 0.75})`);
        gradient.addColorStop(1, `hsla(${l.hue},100%,50%,0)`);
        ctx.fillStyle = gradient;
        ctx.fillRect(l.tx - r, l.ty - r, r * 2, r * 2);
        ctx.restore();
      }
      return true; // signal to remove laser
    }
    return false;
  }

  function drawSpark(s, tnow) {
    const age = tnow - s.born;
    const p = age / s.life;
    if (p >= 1) return true;
    // simple physics
    const drag = 0.98;
    s.vx *= drag;
    s.vy *= drag;
    s.vy += 0.06; // gravity
    s.x += s.vx;
    s.y += s.vy;

    const alpha = 1 - p;
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    ctx.beginPath();
    ctx.fillStyle = `hsla(${s.hue},100%,65%,${0.9 * alpha})`;
    ctx.arc(s.x, s.y, Math.max(0.2, s.size * (1 - p)), 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    return false;
  }

  // main loop
  function frame(now) {
    rafId = requestAnimationFrame(frame);
    // FPS cap
    const elapsedFrame = now - lastFrame;
    const minFrame = 1000 / cfg.maxFPS;
    if (elapsedFrame < minFrame) return;
    lastFrame = now;

    // faint background smear to keep trails (or clear fully)
    ctx.clearRect(0, 0, width, height);

    // Occasionally spawn new lasers based on frequency
    if (rng() < (cfg.laserFrequency * elapsedFrame / 1000)) {
      spawnLaser();
    }

    // Draw lasers (iterate copy to allow splice)
    for (let i = lasers.length - 1; i >= 0; i--) {
      const removed = drawLaser(lasers[i], now);
      if (removed) lasers.splice(i, 1);
    }

    // Draw sparks and remove dead ones
    for (let i = sparks.length - 1; i >= 0; i--) {
      const dead = drawSpark(sparks[i], now);
      if (dead) sparks.splice(i, 1);
    }

    // subtle global ambient glows / small floating lens flares (random)
    if (rng() < 0.02) {
      const x = rng() * width, y = rng() * height;
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      const r = 4 + rng() * 14;
      const g = ctx.createRadialGradient(x, y, 0, x, y, r);
      const h = Math.floor(200 + rng() * 120);
      g.addColorStop(0, `hsla(${h},100%,70%,${0.06 + rng() * 0.08})`);
      g.addColorStop(1, `hsla(${h},100%,45%,0)`);
      ctx.fillStyle = g;
      ctx.fillRect(x - r, y - r, r * 2, r * 2);
      ctx.restore();
    }
  }

  // Public API
  return {
    init: function (options = {}) {
      Object.assign(cfg, options);
      initCanvas();
      // auto-start
      this.start();
      return this;
    },
    start: function () {
      if (running) return;
      running = true;
      lastFrame = performance.now();
      rafId = requestAnimationFrame(frame);
    },
    stop: function () {
      running = false;
      if (rafId) {
        cancelAnimationFrame(rafId);
        rafId = null;
      }
      // clear arrays and canvas
      lasers = [];
      sparks = [];
      if (ctx) {
        ctx.clearRect(0, 0, width, height);
      }
    },
    setOptions: function (o = {}) {
      Object.assign(cfg, o);
      if (o.seed) rng = mulberry32(cfg.seed);
      resize();
    },
    // expose internals for debugging (not normally needed)
    _cfg: cfg
  };
})();

// Auto-init with default options (you can remove this if you want manual control)
LaserBG.init({
  laserFrequency: 0.9,   // lasers per second
  maxConcurrentLasers: 3,
  laserLife: 700,
  laserThickness: 2.6,
  glowRadius: 28,
  sparkCount: 28,
  sparkLife: 600,
  impactFlash: true,
  randomSourceEdges: true,
  mobileScale: 0.6,
  maxFPS: 60
});

/* Usage examples:
   LaserBG.start(); // resume
   LaserBG.stop();  // stop and clear
   LaserBG.setOptions({ laserFrequency: 1.5, maxConcurrentLasers: 5 });
*/
</script>
